1. 10.09.2019. Мария Румянцева: "с. 70, условие первой лабораторной, п. 5. В предыдущем пункте мы присваиваем переменной К хотя бы 4 значения, то есть по идее количество программ у нас от 4 до бесконечности, а в условии - чётко 10."
11.09.2019. Балакшин П.В. Да, верно. Должно быть "В результате получится одна нераспараллеленная программа и 4+ распараллеленных."
fixed

2. 10.09.2019. Мария Румянцева: "с. 73, этап Map, действия с массивом М2. Тут возник вопрос в том, что при сложении с предыдущим элементом нам нужно изначальное его значение или вычисленное на предыдущем этапе. Если вычисленное на предыдущем этапе, то похоже, стоит это указать, потому что у нас вопросы всё-таки возникли, ибо это не будет параллелиться. :)"
11.09.2019. Балакшин П.В. Мы в своё время решили, что у вас должен быть ещё один массив (= копия исходного массива). Т.е. надо просто поподробнее расписать.
fixed

3. 10.09.2019. Мария Румянцева: "В табличке на той же странице в пункте 1 куда-то улетел минус и двойка в имени массива в M2[i-1]"
11.09.2019. Балакшин П.В. Да, верно. Должно быть "... + M2[i-1])..."
fixed

4. 11.09.2019. Балакшин П.В. В 1-й лабораторной в пунктах 3 и 4 использовать ключ -O3, а не -O2.
fixed

5. 12.09.2019 Азат Карапетян. "В первой лабораторной работе по параллельным вычислениям требуется создать одномерный массив длиною N? Или все же двумерный массив NxN?"
13.09.2019. Балакшин П.В. В примере программы указать, что это одномерный массив размерностью N.
fixed

6. 12.09.2019 Александр Пашнин. "В пункте 12 "Необязательное задание №2" для icc указан неактуальный ключ -par-report, вместо него следует использовать -qopt-report-phase=par"
13.09.2019. Балакшин П.В. Дописать, что в случае, если ключ -par-report не работает, то желательно попробовать более актуальный ключ -qopt-report-phase=par.
fixed

7. 13.09.2019. Балакшин П.В. В первой лабе проверить, что число итераций везде =50.
fixed

8. 11.09.2019. Алексей Мишенёв. "стр. 12 определение thread-safe "Внутри функций обращение ко всем общим переменным осуществляется строго последовательно а не непараллельно". Кажется, здесь должно быть просто "строго последовательно а не параллельно".
13.09.2019. Балакшин П.В. Верно. Должно быть "строго последовательно, а не параллельно".
fixed

9. 13.09.2019. Алексей Мишенёв. "11 стр. ОС сама решает как распорядит_ся процессорным временем".
13.09.2019. Балакшин П.В. Верно. Должно быть с мягким знаком.
fixed

10. 13.09.2019. Алексей Мишенёв. "стр. 22 в примере с gcc -О2".
13.09.2019. Балакшин П.В. Верно. Должен быть ключ -O3.
fixed

11. 13.09.2019. Алексей Мишенёв. Сделать человеческими ссылки на Википедию с списке литературы.
невозможно из-за ограничений пакета
Попробуй так:
\href{https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5_%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F}{https://ru.wikipedia.org/wiki/Параллельные\_вычисления}

12. 16.09.2019. Владимир Губарев. Гипертрейдинг (hypertrading) -> гипертрединг (hyperthreading)

13. 16.09.2019. Владимир Губарев. На таких системах *проводяться*

14. 16.09.2019. Владимир Губарев. Частным случаем атомарных операций являются read-modify-write, compare-and-swap, test-and-set, fetch-and-add.

Если я правильно понимаю, отдельной операции RMW не существует, это класс операций, к которым относится CAS, TAS, FAA

15. 16.09.2019. Владимир Губарев. так как накладные *расзоды*

16. 16.09.2019. Владимир Губарев. не выходит из семафора при окончании выполнения области кода если программист забыл освободить ресурс.

Запятая

17. 16.09.2019. Владимир Губарев. Мьютекс - частный случай семафора, при котором данную область кода может захватывать только один поток.

    17.1. Может, "в критическую секцию может входить только один поток"? Или даже в одну из критических секций, т.к. мьютекс может обслуживать сразу несколько.
    17.2. Возможно, стоит более явно указать, что самое важное (скоре, идиологическое) отличие мьютекса от одноместного семафора в том, что мьютекс обязан быть освобожден тем потоком, который его захватил.
    17.3. Далее по тексту: "так как ”легче” классического семафора". Честно говоря, неочевидно, почему так?

18. 16.09.2019. Владимир Губарев. повторные захваты участка кода этим же потоком

Повторный вход в критическую секцию?

19. 16.09.2019. Владимир Губарев. Внутри секции кода необходимо избегать прерываний, чтобы избежать deadlock’a.

Прерывание как сигнал или как, например, pthread_cancel? Если имеется ввиду первое и это, например, sleep, то это не приведет к deadlock, а pthread_cancel или крах всего процесса может оставить блокировку в занятом состоянии

20. 16.09.2019. Владимир Губарев. и поток завершает работу

Поток выходит из критической секции?

21. 16.09.2019. Владимир Губарев. Пример реализации барьера может быть критическая секция, код которой разрешается выполняться только последнему потоку, запросившему выполнение.
    21.1. Примером реализации барьера?
    21.2. Я правильно понимаю, что предполагается, что мы знаем, сколько потоков должно прийти в барьер?

22. 16.09.2019. Владимир Губарев. с. 20. Описание RCU

    22.1. Непонятно, что есть конец работы алгоритма
    22.2. Замена указателя может быть проведена не только CASом, но и отдельной взаимной блокировкой для писателей или отдельным потоком (например, как сделано в urcu-qsbr) или еще более тяжелой вещью в последних версиях Linux - membarrier(2)
    22.3. Если это имеет смысл, то для интересующихся было бы здорово пояснить, как, почему и когда RCU может быть полезен

23. 16.09.2019. Владимир Губарев. с. 21. Например, если мы хотим сделать общую целочисленную переменную для нескольких потоков, нет
смысла создавать mutex или semaphore, более оптимально сделать переменную атомарной. Всегда надо учитывать накладные расходы на создание блокировок и время разработки.

Кажется, надо конкретизировать задачу, т.к. решение неочевидно. Если я правильно понял, имеется в виду атомарный целочисленный счетчик, чтобы что-то считать

24. 16.09.2019. Владимир Губарев. Управление количеством нитей.

Может, потоков выполнения?

25. 16.09.2019. Владимир Губарев. с. 36. Инструменты измерения времени

Если речь про один хост (даже с несколькими сокетами), то еще можно использовать RDTSC или clock_gettime(CLOCK_MONOTONIC).
walltime подвержен спецэффектам в виде NTP или злого сисадмина, который меняет часы по ходу работы программы.

26. 16.09.2019. Владимир Губарев. Менеджеры управления памятью для параллельных программ

Было бы здорово добавить шикарный многопоточный jemalloc и еще один свежий mimalloc (https://github.com/microsoft/mimalloc)

27. 16.09.2019. Владимир Губарев. поток1 захватил замок1;

Возможно, дело привычки, но для меня "блокировка" звучит лучше "замка"

28. 16.09.2019. Владимир Губарев. В результате получится одна нераспараллеленная программа и десять распараллеленных.

Пять программ? (seq + par-(K1, K2, K3, K4)) = 5

29. 18.09.2019. Владимир Губарев. Lock-free алгоритмы

struct data {
2 int volatile nShared1;
3 / padding for cache line=64 byte /
4 char _padding1[64];
5 int volatile nShared2;
6 / padding for cache line=64 byte /
7 char _padding2[64];
8 };

Паддинги должны быть не 64 байта, а 60, т.к. 4 байта в кэш линии уже занятом intом

+ не имеет ли смысла использовать C11 и его атомики вместо volatile?

30. 18.09.2019. Владимир Губарев. следуюет резмещать по одной переменной

31. 18.09.2019. Владимир Губарев. weak/strong CAS

> Weak версия может вернуть false в случае, когда считанное значение было равно ожидаемому. Strong всегда возвращает правильное значение.

Было бы здорово объяснить, как так может быть и на каких архитектурах, потому что вопрос максимально неочевидный. О том, что это явление существует, говорят все, но на вопрос: "А это почему" - ответ я видел ровно в одной лекции по атомарности (https://www.youtube.com/watch?v=ZQFzMfHIxng)

32. 18.09.2019. Владимир Губарев. Разделяемый объект называется lock-free объектом, если он гарантирует, что некоторый поток закончит выполнение операции над объектом за конечное количество шагов вне зависимости от результатов работы других потоков.

Если я правильно понимаю, выполнение lock-free (не wait-free) алгоритма для конкретного потока при определенном везении может никогда не закончиться, если будет постоянно проигрывать конкуренцию за механизм синхронизации а-ля starvation (например, если каждый раз после очередной загрузки актуального значения для CAS его конкурент будет менять значение и, соответственно, поток будет идти на очередную итерацию CAS цикла). 
