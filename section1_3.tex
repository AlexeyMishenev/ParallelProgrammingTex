{ %section1_3
	\subsection{Основные подходы к распараллеливанию}
	\Large\parНа практике сложилось достаточное большое количество шаблонов параллельного программирования. Однако все эти шаблоны в своей основе используют всего два базовых подхода к распараллеливанию:
	\begin{itemize}
		\item\textbf{Распараллеливание по данным:} Программист находит в программе массив данных, элементы которого программа последовательно обрабатывает в некоторой функции func. Затем программист пытается разбить этот массив данных на блоки, которые могут быть обработаны в func независимо друг от друга. Затем программист запускает сразу несколько потоков, каждый из которых выполняет func, но при этом обрабатывает в этой функции отличные от других потоков блоки данных.
		\item\textbf{Распараллеливание по инструкциям :} Программист находит в программе последовательно вызываемые функции, процесс работы которых не влияет друг на друга (такие функции не изменяют общие глобальные переменные, а результаты одной не используются в работе другой). Затем эти функции программист запускает в параллельных потоках.
	\end{itemize}
	\parДва описанных метода легче понять на аналогии из обыденной жизни. Пусть два студента получили в стройотряде задание подмести улицу и покрасить забор. Если студенты решат использовать распараллеливание по данным, он будут сначала вместе подметать улицу, а затем вместе же красить забор. Если они решат использовать распараллеливание по инструкциям, то один студент полностью подметёт улицу, а другой покрасит в это время весь забор.
	\parВ большем числе случаев решение об использовании первого или второго метода является очевидным в силу внутренних особенностей распараллеливаемой программы. Однако некоторые задачи внешне одинаково хорошо распараллеливаются любым из двух методов. В этом случае выбор будет определяться тем, какой из методов более равномерно загружает потоки. В идеале все потоки должны приблизительно одновременно заканчивать выделенную им работу, чтобы оптимально загрузить ядра (процессоры) и чтобы закончившие работу потоки не простаивали в ожидании завершения работы соседними потоками.
	\par
}